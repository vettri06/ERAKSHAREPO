"""
Vulnerability Checker Module
Checks service/software vulnerabilities using NVD API v2.0 with AI-enhanced analysis
"""
import json
import logging
import re
try:
    import requests
except ImportError:
    requests = None
import time
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta
import traceback

class Version:
    """Simple version comparator for version ranges"""
    def __init__(self, version_str):
        self.raw = str(version_str)
        self.parts = []
        # Extract numeric parts, handling common delimiters
        # This is a heuristic approach since we don't have 'packaging'
        try:
            # Clean up string (remove 'v', leading/trailing spaces)
            clean_ver = self.raw.lower().strip().lstrip('v')
            # Split by dot, hyphen, underscore
            for part in re.split(r'[.\-_]', clean_ver):
                if part.isdigit():
                    self.parts.append(int(part))
                else:
                    # Handle mixed parts like '1a' -> 1
                    match = re.match(r'^(\d+)', part)
                    if match:
                        self.parts.append(int(match.group(1)))
        except:
            pass
    
    def __lt__(self, other):
        # Pad with zeros for comparison (e.g., 1.2 < 1.2.1)
        len_diff = len(other.parts) - len(self.parts)
        my_parts = self.parts + [0] * max(0, len_diff)
        other_parts = other.parts + [0] * max(0, -len_diff)
        return my_parts < other_parts
    
    def __eq__(self, other):
        len_diff = len(other.parts) - len(self.parts)
        my_parts = self.parts + [0] * max(0, len_diff)
        other_parts = other.parts + [0] * max(0, -len_diff)
        return my_parts == other_parts
        
    def __le__(self, other):
        return self < other or self == other
        
    def __ge__(self, other):
        return not (self < other)

    def __gt__(self, other):
        return not (self <= other)

logger = logging.getLogger(__name__)
class VulnerabilityChecker:
    """Checks for known vulnerabilities with AI-enhanced risk assessment"""
    def __init__(self, api_key: str = None):
        self.nvd_api_base = "https://services.nvd.nist.gov/rest/json/cves/2.0"  
        self.api_key = api_key
        self.cache_file = "vuln_cache.json"
        self.cache = self.load_cache()
        self.AI_RISK_FACTORS = {
            'iot_device_risk_multiplier': 1.5,
            'router_risk_multiplier': 2.0,
            'camera_risk_multiplier': 1.8,
            'unknown_device_risk_multiplier': 1.3,
            'recent_vuln_weight': 1.2,
            'exploit_available_weight': 1.5
        }
        self.VERSION_MAPPING = {
            'nginx': '1.24.0',
            'apache': '2.4.58',
            'openssh': '9.6p1',
            'vsftpd': '3.0.5',
            'postfix': '3.8.3',
            'bind': '9.18.21',
            'lighttpd': '1.4.73',
            'dropbear': '2022.83',
            'dnsmasq': '2.90',
            'unbound': '1.19.0'
        }
        self.DOWNLOAD_LINKS = {
            'nginx': 'https://nginx.org/en/download.html',
            'apache': 'https://httpd.apache.org/download.cgi',
            'openssh': 'https://www.openssh.com/portable.html',
            'vsftpd': 'https://security.appspot.com/vsftpd.html',
            'postfix': 'https://www.postfix.org/download.html',
            'bind': 'https://www.isc.org/download/',
            'lighttpd': 'https://www.lighttpd.net/download/',
            'dropbear': 'https://matt.ucc.asn.au/dropbear/dropbear.html',
            'dnsmasq': 'https://thekelleys.org.uk/dnsmasq/doc.html',
            'unbound': 'https://nlnetlabs.nl/projects/unbound/download/'
        }
        self.PRODUCT_DATABASE = {
            'unbound': {
                'vendor': 'nlnetlabs',
                'category': 'dns-resolver',
                'first_release_year': 2007,
                'cpe_prefix': 'cpe:2.3:a:nlnetlabs:unbound:',
                'valid_keywords': ['unbound', 'dns', 'resolver']
            },
            'dnsmasq': {
                'vendor': 'dnsmasq',
                'category': 'dns-dhcp',
                'first_release_year': 2000,
                'cpe_prefix': 'cpe:2.3:a:thekelleys:dnsmasq:',
                'valid_keywords': ['dnsmasq', 'dns', 'dhcp']
            },
            'nginx': {
                'vendor': 'nginx',
                'category': 'web-server',
                'first_release_year': 2004,
                'cpe_prefix': 'cpe:2.3:a:nginx:nginx:',
                'valid_keywords': ['nginx', 'http', 'server']
            },
            'lighttpd': {
                'vendor': 'lighttpd',
                'category': 'web-server',
                'first_release_year': 2003,
                'cpe_prefix': 'cpe:2.3:a:lighttpd:lighttpd:',
                'valid_keywords': ['lighttpd', 'lighty']
            },
            'apache': {
                'vendor': 'apache',
                'category': 'web-server',
                'first_release_year': 1995,
                'cpe_prefix': 'cpe:2.3:a:apache:http_server:',
                'valid_keywords': ['apache', 'httpd', 'http server']
            },
            'openssh': {
                'vendor': 'openssh',
                'category': 'ssh-server',
                'first_release_year': 1999,
                'cpe_prefix': 'cpe:2.3:a:openbsd:openssh:',
                'valid_keywords': ['openssh', 'ssh']
            },
            'dropbear': {
                'vendor': 'dropbear',
                'category': 'ssh-server',
                'first_release_year': 2004,
                'cpe_prefix': 'cpe:2.3:a:dropbear_project:dropbear:',
                'valid_keywords': ['dropbear']
            },
            'vsftpd': {
                'vendor': 'vsftpd',
                'category': 'ftp-server',
                'first_release_year': 2001,
                'cpe_prefix': 'cpe:2.3:a:vsftpd_project:vsftpd:',
                'valid_keywords': ['vsftpd', 'ftp']
            },
            'postfix': {
                'vendor': 'postfix',
                'category': 'smtp-server',
                'first_release_year': 1998,
                'cpe_prefix': 'cpe:2.3:a:postfix:postfix:',
                'valid_keywords': ['postfix', 'smtp']
            },
            'bind': {
                'vendor': 'isc',
                'category': 'dns-server',
                'first_release_year': 1984,
                'cpe_prefix': 'cpe:2.3:a:isc:bind:',
                'valid_keywords': ['bind', 'named', 'dns']
            },
            'proftpd': {
                'vendor': 'proftpd',
                'category': 'ftp-server',
                'first_release_year': 1997,
                'cpe_prefix': 'cpe:2.3:a:proftpd:proftpd:',
                'valid_keywords': ['proftpd', 'ftp']
            },
            'exim': {
                'vendor': 'exim',
                'category': 'smtp-server',
                'first_release_year': 1995,
                'cpe_prefix': 'cpe:2.3:a:exim:exim:',
                'valid_keywords': ['exim', 'smtp']
            },
            'sendmail': {
                'vendor': 'sendmail',
                'category': 'smtp-server',
                'first_release_year': 1983,
                'cpe_prefix': 'cpe:2.3:a:sendmail:sendmail:',
                'valid_keywords': ['sendmail', 'smtp']
            },
            'net-snmp': {
                'vendor': 'net-snmp',
                'category': 'snmp-server',
                'first_release_year': 2000,
                'cpe_prefix': 'cpe:2.3:a:net-snmp:net-snmp:',
                'valid_keywords': ['net-snmp', 'snmp']
            },
            'miniupnpd': {
                'vendor': 'miniupnp',
                'category': 'upnp-server',
                'first_release_year': 2007,
                'cpe_prefix': 'cpe:2.3:a:miniupnp:miniupnpd:',
                'valid_keywords': ['miniupnpd', 'upnp']
            }
        }
        self.SERVICE_TO_PRODUCT = {
            'http': {
                'products': ['nginx', 'apache', 'lighttpd'],
                'confidence': 'LOW',
                'generic_risk': {
                    'severity': 'MEDIUM',
                    'title': 'Exposed HTTP service',
                    'description': 'Unknown web server implementation exposed',
                    'confidence': 'LOW',
                    'ai_risk_score': 0.6
                }
            },
            'https': {
                'products': ['nginx', 'apache', 'lighttpd'],
                'confidence': 'LOW',
                'generic_risk': {
                    'severity': 'MEDIUM',
                    'title': 'Exposed HTTPS service',
                    'description': 'Unknown web server with TLS exposed',
                    'confidence': 'LOW',
                    'ai_risk_score': 0.5
                }
            },
            'ssh': {
                'products': ['openssh', 'dropbear'],
                'confidence': 'MEDIUM',
                'generic_risk': {
                    'severity': 'HIGH',
                    'title': 'Exposed SSH service',
                    'description': 'SSH service accessible, ensure strong authentication',
                    'confidence': 'HIGH',
                    'ai_risk_score': 0.7
                }
            },
            'ftp': {
                'products': ['vsftpd', 'proftpd'],
                'confidence': 'MEDIUM',
                'generic_risk': {
                    'severity': 'HIGH',
                    'title': 'Exposed FTP service',
                    'description': 'FTP may transmit credentials in plain text',
                    'confidence': 'HIGH',
                    'ai_risk_score': 0.8
                }
            },
            'dns': {
                'products': ['bind', 'dnsmasq', 'unbound'],
                'confidence': 'LOW',
                'generic_risk': {
                    'severity': 'MEDIUM',
                    'title': 'Exposed DNS service',
                    'description': 'DNS service accessible, potential amplification attacks',
                    'confidence': 'MEDIUM',
                    'ai_risk_score': 0.6
                }
            },
            'smtp': {
                'products': ['postfix', 'exim', 'sendmail'],
                'confidence': 'LOW',
                'generic_risk': {
                    'severity': 'MEDIUM',
                    'title': 'Exposed SMTP service',
                    'description': 'Mail transfer agent accessible',
                    'confidence': 'MEDIUM',
                    'ai_risk_score': 0.5
                }
            },
            'telnet': {
                'products': [],
                'confidence': 'HIGH',
                'generic_risk': {
                    'severity': 'CRITICAL',
                    'title': 'Telnet service detected',
                    'description': 'Telnet transmits credentials in plain text',
                    'confidence': 'HIGH',
                    'ai_risk_score': 0.9
                }
            },
            'snmp': {
                'products': ['net-snmp'],
                'confidence': 'MEDIUM',
                'generic_risk': {
                    'severity': 'HIGH',
                    'title': 'Exposed SNMP service',
                    'description': 'SNMP may use default community strings',
                    'confidence': 'HIGH',
                    'ai_risk_score': 0.7
                }
            },
            'upnp': {
                'products': ['miniupnpd'],
                'confidence': 'MEDIUM',
                'generic_risk': {
                    'severity': 'HIGH',
                    'title': 'UPnP service detected',
                    'description': 'UPnP can be abused for NAT traversal',
                    'confidence': 'HIGH',
                    'ai_risk_score': 0.8
                }
            }
        }
        self.INFRASTRUCTURE_VENDORS = [
            'netgate', 'pfsense', 'vmware', 'cisco', 'juniper',
            'fortinet', 'checkpoint', 'palo alto', 'arista'
        ]

    def check_version_vulnerability(self, version_str: str, cve_data: Dict) -> bool:
        """Check if version falls within vulnerable range of CVE"""
        if not version_str:
            return True # If no version known, assume vulnerable
            
        try:
            current_ver = Version(version_str)
            configurations = cve_data.get('configurations', [])
            
            # If no configurations, we can't check ranges.
            if not configurations:
                return True
                
            for config in configurations:
                nodes = config.get('nodes', [])
                for node in nodes:
                    cpe_matches = node.get('cpeMatch', [])
                    for match in cpe_matches:
                        if match.get('vulnerable'):
                            # Check ranges
                            start_inc = match.get('versionStartIncluding')
                            start_exc = match.get('versionStartExcluding')
                            end_inc = match.get('versionEndIncluding')
                            end_exc = match.get('versionEndExcluding')
                            
                            # If no range attributes are present, it implies a specific version match or all versions
                            # For simplicity/safety, if ANY range param is present, we enforce it.
                            # If NONE are present, we skip this match entry (unless we parsed the CPE string, which is complex)
                            if not any([start_inc, start_exc, end_inc, end_exc]):
                                continue

                            in_range = True
                            
                            if start_inc:
                                if not (current_ver >= Version(start_inc)): in_range = False
                            if start_exc:
                                if not (current_ver > Version(start_exc)): in_range = False
                            if end_inc:
                                if not (current_ver <= Version(end_inc)): in_range = False
                            if end_exc:
                                if not (current_ver < Version(end_exc)): in_range = False
                                
                            if in_range:
                                return True
                                
            return False
            
        except Exception as e:
            logger.debug(f"Version check error: {e}")
            return True

    def load_cache(self) -> Dict:
        """Load vulnerability cache from file"""
        try:
            with open(self.cache_file, 'r') as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            return {}
    def save_cache(self):
        """Save vulnerability cache to file"""
        try:
            with open(self.cache_file, 'w') as f:
                json.dump(self.cache, f, indent=2)
        except Exception as e:
            logger.error(f"Error saving cache: {e}")

    def clear_cache(self):
        """Clear the vulnerability cache and delete the cache file"""
        self.cache = {}
        try:
            if os.path.exists(self.cache_file):
                os.remove(self.cache_file)
                logger.info(f"Deleted cache file: {self.cache_file}")
        except Exception as e:
            logger.error(f"Error clearing cache file: {e}")
    def check_device_vulnerabilities(self, device_info: Dict, nmap_results: Dict) -> List[Dict]:
        """Check device services for known vulnerabilities with AI-enhanced risk assessment"""
        vulnerabilities = []
        vendor = device_info.get('vendor', '').lower()
        hostname = ''
        device_type = device_info.get('device_type', '').lower()
        is_infrastructure = self.is_infrastructure_device(vendor, hostname, device_type)
        ports_info = nmap_results.get('ports', [])
        for port_info in ports_info:
            service_name = port_info.get('service', 'unknown')
            product = str(port_info.get('product', '')).lower()
            version = port_info.get('version', '')
            port = port_info.get('port', 0)
            product_vulns = self.check_product_vulnerabilities(
                service_name, product, version, is_infrastructure, device_type
            )
            for vuln in product_vulns:
                self.apply_ai_risk_assessment(vuln, device_type, service_name)
                vulnerabilities.append(vuln)
            generic_risk = self.get_generic_service_risk(
                service_name, port, version, is_infrastructure, device_type
            )
            if generic_risk:
                # Only add generic risk if no specific product vulnerabilities were found for this service
                # This prevents double reporting (Specific CVE + Generic "Exposed Service")
                if not product_vulns:
                    self.apply_ai_risk_assessment(generic_risk, device_type, service_name)
                    vulnerabilities.append(generic_risk)
        
        port_risks = self.check_port_based_risks(
            nmap_results.get('ports', []),
            is_infrastructure,
            device_type
        )
        vulnerabilities.extend(port_risks)
        if 'iot' in device_type or 'camera' in device_type or 'smart' in device_type:
            iot_predictions = self.predict_iot_vulnerabilities(device_info, nmap_results)
            vulnerabilities.extend(iot_predictions)
        unique_vulns = self.deduplicate_vulnerabilities(vulnerabilities)
        sorted_vulns = self.sort_vulnerabilities_by_ai_risk(unique_vulns)
        return sorted_vulns
    def apply_ai_risk_assessment(self, vulnerability: Dict, device_type: str, service_name: str):
        """Apply AI-based risk assessment to vulnerabilities"""
        base_score = vulnerability.get('ai_risk_score', 0.5)
        if 'iot' in device_type:
            base_score *= self.AI_RISK_FACTORS['iot_device_risk_multiplier']
        elif 'router' in device_type or 'gateway' in device_type:
            base_score *= self.AI_RISK_FACTORS['router_risk_multiplier']
        elif 'camera' in device_type:
            base_score *= self.AI_RISK_FACTORS['camera_risk_multiplier']
        elif 'unknown' in device_type:
            base_score *= self.AI_RISK_FACTORS['unknown_device_risk_multiplier']
        if service_name in ['telnet', 'ftp', 'vnc']:
            base_score *= 1.3  
        if 'published_date' in vulnerability:
            try:
                pub_date = datetime.fromisoformat(vulnerability['published_date'].replace('Z', ''))
                days_old = (datetime.now() - pub_date).days
                if days_old < 90:  
                    base_score *= self.AI_RISK_FACTORS['recent_vuln_weight']
            except:
                pass
        vulnerability['ai_risk_score'] = min(1.0, base_score)
        ai_score = vulnerability['ai_risk_score']
        if ai_score >= 0.9:
            vulnerability['severity'] = 'CRITICAL'
        elif ai_score >= 0.7:
            vulnerability['severity'] = 'HIGH'
        elif ai_score >= 0.5:
            vulnerability['severity'] = 'MEDIUM'
        else:
            vulnerability['severity'] = 'LOW'
        vulnerability['ai_analysis'] = {
            'risk_score': ai_score,
            'factors_applied': [
                f"Device type: {device_type}",
                f"Service: {service_name}"
            ]
        }
    def is_infrastructure_device(self, vendor: str, hostname: str, device_type: str = '') -> bool:
        """Check if device is likely infrastructure (router, firewall, etc.)"""
        vendor_lower = vendor.lower()
        hostname_lower = hostname.lower()
        device_type_lower = device_type.lower()
        
        # Check explicit device type first
        if 'router' in device_type_lower or 'gateway' in device_type_lower or 'firewall' in device_type_lower:
            return True

        for infra_vendor in self.INFRASTRUCTURE_VENDORS:
            if infra_vendor in vendor_lower:
                return True
        
        infra_patterns = ['pfsense', 'router', 'gateway', 'firewall', 'switch']
        for pattern in infra_patterns:
            if pattern in hostname_lower:
                return True
        
        if 'vmware' in vendor_lower or '00:0c:29' in vendor_lower or '00:50:56' in vendor_lower:
            return True
            
        return False
    def check_product_vulnerabilities(self, service_name: str, product: str, version: str, 
                                    is_infrastructure: bool, device_type: str) -> List[Dict]:
        """Check specific product/software for vulnerabilities with AI filtering"""
        vulnerabilities = []
        product_info = self.identify_product(service_name, product)
        if not product_info:
            return vulnerabilities
        product_name = product_info['name']
        confidence = product_info['confidence']
        if version:
            try:
                version_year = self.extract_version_year(version, product_name)
                if version_year and version_year < 2010:
                    confidence = 'LOW'
            except:
                pass
        search_term = self.get_product_search_term(product_name, product_info.get('vendor'))
        
        # If infrastructure device and version is unknown, skip NVD search to avoid false positives (like ancient CVEs)
        # Routers often use embedded/custom builds where version detection fails
        if is_infrastructure and not version:
            logger.debug(f"Skipping NVD search for {product_name} on infrastructure device due to missing version")
            return vulnerabilities

        if search_term:
            cve_results = self.search_nvd_cves(
                search_term, 
                version, 
                product_name,
                product_info.get('vendor'),
                is_infrastructure,
                device_type
            )
            for vuln in cve_results:
                if self.validate_cve_product(vuln, product_name, product_info.get('vendor')):
                    if confidence == 'LOW':
                        vuln['confidence'] = 'LOW'
                        vuln['reason'] = 'Product identification uncertain'
                    elif confidence == 'MEDIUM':
                        vuln['confidence'] = 'MEDIUM'
                    else:
                        vuln['confidence'] = 'HIGH'
                    if is_infrastructure:
                        vuln['severity'] = self.downgrade_severity(vuln.get('severity', 'MEDIUM'))
                        vuln['infrastructure_note'] = 'Device appears to be infrastructure, likely patched'
                    vulnerabilities.append(vuln)
        return vulnerabilities
    def identify_product(self, service_name: str, product_str: str) -> Optional[Dict]:
        """Identify the actual product from service detection"""
        product_lower = product_str.lower()
        for product_name, product_data in self.PRODUCT_DATABASE.items():
            if product_name in product_lower:
                return {
                    'name': product_name,
                    'vendor': product_data['vendor'],
                    'confidence': 'HIGH' if product_name in product_lower else 'MEDIUM'
                }
        if service_name.lower() in self.SERVICE_TO_PRODUCT:
            mapping = self.SERVICE_TO_PRODUCT[service_name.lower()]
            products = mapping['products']
            for prod in products:
                if prod in product_lower:
                    return {
                        'name': prod,
                        'vendor': self.PRODUCT_DATABASE[prod]['vendor'],
                        'confidence': 'HIGH'
                    }
            if products:
                return {
                    'name': products[0],  
                    'vendor': self.PRODUCT_DATABASE[products[0]]['vendor'],
                    'confidence': mapping['confidence']
                }
        return None
    def get_product_search_term(self, product_name: str, vendor: str = None) -> Optional[str]:
        """Get proper search term for product"""
        if product_name in self.PRODUCT_DATABASE:
            product_data = self.PRODUCT_DATABASE[product_name]
            if vendor:
                return f"{vendor} {product_name}"
            else:
                return f"{product_data['vendor']} {product_name}"
        return product_name
    def extract_version_year(self, version: str, product_name: str) -> Optional[int]:
        """Extract implied year from version string"""
        try:
            year_patterns = [
                r'(\d{4})',  
                r'v?(\d{2})(?:\D|$)',  
            ]
            for pattern in year_patterns:
                match = re.search(pattern, version)
                if match:
                    year_str = match.group(1)
                    if len(year_str) == 4:
                        year = int(year_str)
                    elif len(year_str) == 2:
                        year = 2000 + int(year_str) if int(year_str) < 50 else 1900 + int(year_str)
                    if 1990 <= year <= datetime.now().year:
                        return year
            if product_name in self.PRODUCT_DATABASE:
                return self.PRODUCT_DATABASE[product_name]['first_release_year']
        except:
            pass
        return None
    def validate_cve_product(self, vuln: Dict, product_name: str, vendor: str = None) -> bool:
        """Validate that CVE actually belongs to the product"""
        cve_id = vuln.get('id', '')
        description = vuln.get('description', '').lower()
        cve_year = self.extract_cve_year(cve_id)
        if cve_year and product_name in self.PRODUCT_DATABASE:
            first_year = self.PRODUCT_DATABASE[product_name]['first_release_year']
            if cve_year < first_year - 2:  
                logger.debug(f"Rejecting {cve_id}: product {product_name} released {first_year}, CVE from {cve_year}")
                return False
        if product_name in self.PRODUCT_DATABASE:
            valid_keywords = self.PRODUCT_DATABASE[product_name]['valid_keywords']
            has_keyword = any(keyword in description for keyword in valid_keywords)
            if not has_keyword:
                logger.debug(f"Rejecting {cve_id}: no valid keywords for {product_name}")
                return False
            false_positives = ['unbound variable', 'unbound memory', 'unbound access']
            for fp in false_positives:
                if fp in description and product_name == 'unbound':
                    logger.debug(f"Rejecting {cve_id}: false positive - '{fp}'")
                    return False
        return True
    def extract_cve_year(self, cve_id: str) -> Optional[int]:
        """Extract year from CVE ID"""
        try:
            match = re.match(r'CVE-(\d{4})-\d+', cve_id)
            if match:
                return int(match.group(1))
        except:
            pass
        return None
    def search_nvd_cves(self, search_term: str, version: str, product_name: str, 
                       vendor: str, is_infrastructure: bool, device_type: str) -> List[Dict]:
        """Search NVD API v2.0 with AI-enhanced filtering"""
        vulnerabilities = []
        cache_key = f"{search_term}_{version}_{product_name}_{device_type}"
        if cache_key in self.cache:
            cached_data = self.cache[cache_key]
            cache_date = datetime.fromisoformat(cached_data.get('cached_date', '2000-01-01'))
            if datetime.now() - cache_date < timedelta(days=7):
                return cached_data.get('vulnerabilities', [])
        try:
            if requests is None:
                logger.warning("Requests library not installed. Cannot query NVD API.")
                return vulnerabilities

            params = {
                'keywordSearch': search_term,
                'resultsPerPage': 10,
            }
            if version:
                params['keywordSearch'] = f'{search_term} {version}'
            headers = {
                'User-Agent': 'IoT-Security-Scanner/3.0 (Academic/Research)'
            }
            if self.api_key:
                headers['apiKey'] = self.api_key
            else:
                logger.debug("No API key - applying rate limiting (1.5s delay)")
                time.sleep(1.5)  
            logger.debug(f"Querying NVD API for: {search_term}")
            response = requests.get(
                self.nvd_api_base,
                params=params,
                headers=headers,
                timeout=15
            )
            if response.status_code == 200:
                data = response.json()
                raw_vulns = self.parse_nvd_response_v2(data, search_term, version, device_type)
                filtered_vulns = []
                for vuln in raw_vulns:
                    cvss_score = vuln.get('cvss_score', 0.0)
                    if 'iot' in device_type or 'camera' in device_type:
                        threshold = 5.0  
                    elif 'router' in device_type or 'gateway' in device_type:
                        threshold = 6.0  
                    else:
                        threshold = 7.0  
                    if cvss_score >= threshold:
                        if self.validate_cve_product(vuln, product_name, vendor):
                            filtered_vulns.append(vuln)
                vulnerabilities = filtered_vulns
                self.cache[cache_key] = {
                    'vulnerabilities': vulnerabilities,
                    'cached_date': datetime.now().isoformat(),
                    'device_type': device_type
                }
                self.save_cache()
                logger.info(f"Found {len(vulnerabilities)} vulnerabilities for {search_term}")
            elif response.status_code == 403:
                logger.warning("NVD API rate limit reached or access forbidden.")
                logger.warning("Consider getting an API key from: https://nvd.nist.gov/developers/request-an-api-key")
            elif response.status_code == 429:
                logger.warning("Rate limit exceeded. Adding delay...")
                time.sleep(30)  
            else:
                logger.error(f"NVD API error: {response.status_code} - {response.text[:200]}")
        except requests.exceptions.Timeout:
            logger.warning("NVD API timeout.")
        except requests.exceptions.RequestException as e:
            logger.error(f"Network error querying NVD API: {e}")
        except Exception as e:
            logger.error(f"Error querying NVD API: {e}")
        return vulnerabilities
    def parse_nvd_response_v2(self, data: Dict, search_term: str, version: str, device_type: str) -> List[Dict]:
        """Parse NVD API v2.0 response with AI context"""
        vulnerabilities = []
        try:
            if 'vulnerabilities' not in data:
                logger.debug("No vulnerabilities in response")
                return vulnerabilities
            cve_items = data['vulnerabilities']
            for item in cve_items:
                cve_data = item.get('cve', {})
                cve_id = cve_data.get('id', '')
                description = ''
                descriptions = cve_data.get('descriptions', [])
                for desc in descriptions:
                    if desc.get('lang') == 'en':
                        description = desc.get('value', '')
                        break
                metrics = cve_data.get('metrics', {})
                cvss_score = 0.0
                severity = 'MEDIUM'
                if 'cvssMetricV31' in metrics and metrics['cvssMetricV31']:
                    cvss_data = metrics['cvssMetricV31'][0].get('cvssData', {})
                    cvss_score = cvss_data.get('baseScore', 0.0)
                    severity = cvss_data.get('baseSeverity', 'MEDIUM')
                elif 'cvssMetricV30' in metrics and metrics['cvssMetricV30']:
                    cvss_data = metrics['cvssMetricV30'][0].get('cvssData', {})
                    cvss_score = cvss_data.get('baseScore', 0.0)
                    severity = cvss_data.get('baseSeverity', 'MEDIUM')
                elif 'cvssMetricV2' in metrics and metrics['cvssMetricV2']:
                    cvss_data = metrics['cvssMetricV2'][0].get('cvssData', {})
                    cvss_score = cvss_data.get('baseScore', 0.0)
                    if cvss_score >= 9.0:
                        severity = 'CRITICAL'
                    elif cvss_score >= 7.0:
                        severity = 'HIGH'
                    elif cvss_score >= 4.0:
                        severity = 'MEDIUM'
                    else:
                        severity = 'LOW'
                if cvss_score == 0.0:
                    continue
                if not self.is_cve_relevant_for_device(cve_id, description, device_type):
                    continue
                
                # Check version range if version is provided
                if version and not self.check_version_vulnerability(version, cve_data):
                    logger.debug(f"Skipping {cve_id} - version {version} not in vulnerable range")
                    continue

                ai_risk_score = self.calculate_ai_risk_score(cvss_score, device_type, description)
                remediation, download_link = self.get_remediation_suggestion(search_term, version)
                vuln_info = {
                    'id': cve_id,
                    'title': f"{search_term}: {cve_id}",
                    'description': description[:500],
                    'severity': severity,
                    'cvss_score': cvss_score,
                    'ai_risk_score': ai_risk_score,
                    'software': search_term,
                    'version_checked': version,
                    'published_date': cve_data.get('published', ''),
                    'device_type_context': device_type,
                    'remediation': remediation,
                    'download_link': download_link
                }
                references = cve_data.get('references', [])
                if references:
                    vuln_info['references'] = [
                        ref.get('url', '') for ref in references[:3]
                    ]
                vulnerabilities.append(vuln_info)
        except Exception as e:
            logger.error(f"Error parsing NVD v2.0 response: {e}")
        return vulnerabilities
    def get_remediation_suggestion(self, software: str, current_version: str = None) -> Tuple[str, Optional[str]]:
        """Get specific remediation suggestion with target version and download link"""
        software_lower = software.lower()
        
        # Check if we have a specific target version for this software
        target_version = None
        for key, version in self.VERSION_MAPPING.items():
            if key in software_lower:
                target_version = version
                break
        
        # Get download link if available
        download_link = None
        for key, link in self.DOWNLOAD_LINKS.items():
            if key in software_lower:
                download_link = link
                break

        suggestion = ""
        if target_version:
            if current_version:
                suggestion = f"Current version: {current_version}\nRecommended version: {target_version}\n\nPlease update {software} to the recommended version or later."
            else:
                suggestion = f"Recommended version: {target_version}\n\nPlease update {software} to the recommended version or later."
        else:
            suggestion = "Please update the software to the latest stable version."

        return suggestion, download_link

    def is_cve_relevant_for_device(self, cve_id: str, description: str, device_type: str) -> bool:
        """AI-based check if CVE is relevant for specific device type"""
        description_lower = description.lower()
        iot_keywords = ['iot', 'embedded', 'firmware', 'camera', 'sensor', 'smart', 'home']
        router_keywords = ['router', 'gateway', 'wifi', 'wireless', 'access point']
        camera_keywords = ['camera', 'surveillance', 'video', 'stream', 'dvr', 'nvr']
        if 'iot' in device_type:
            return any(keyword in description_lower for keyword in iot_keywords)
        elif 'router' in device_type or 'gateway' in device_type:
            return any(keyword in description_lower for keyword in router_keywords)
        elif 'camera' in device_type:
            return any(keyword in description_lower for keyword in camera_keywords)
        return True
    def calculate_ai_risk_score(self, cvss_score: float, device_type: str, description: str) -> float:
        """Calculate AI-enhanced risk score"""
        base_score = cvss_score / 10.0  
        if 'iot' in device_type or 'camera' in device_type:
            base_score *= 1.3
        elif 'router' in device_type or 'gateway' in device_type:
            base_score *= 1.4
        high_impact_keywords = ['remote code execution', 'rce', 'privilege escalation', 
                               'authentication bypass', 'arbitrary code execution']
        if any(keyword in description.lower() for keyword in high_impact_keywords):
            base_score *= 1.2
        return min(1.0, base_score)
    def get_generic_service_risk(self, service_name: str, port: int, 
                                version: str, is_infrastructure: bool, device_type: str) -> Optional[Dict]:
        """Get generic risk for service (no specific CVE) with AI scoring"""
        service_lower = service_name.lower()
        
        # Whitelist standard services for infrastructure (Routers/Gateways)
        # Routers normally have DNS (53), HTTP (80), HTTPS (443) for admin
        if is_infrastructure:
            if service_lower in ['http', 'https', 'ssl/http', 'dns', 'domain']:
                logger.debug(f"Whitelisting generic {service_name} risk for infrastructure device")
                return None

        if service_lower in self.SERVICE_TO_PRODUCT:
            generic_risk = self.SERVICE_TO_PRODUCT[service_lower]['generic_risk'].copy()
            if is_infrastructure:
                generic_risk['severity'] = self.downgrade_severity(generic_risk['severity'])
                generic_risk['infrastructure_note'] = 'Infrastructure device - evaluate carefully'
            if 'iot' in device_type or 'camera' in device_type:
                generic_risk['severity'] = self.upgrade_severity(generic_risk['severity'])
                generic_risk['device_type_note'] = f'IoT/Camera device - {generic_risk["severity"]} risk'
            generic_risk['type'] = 'generic_service_risk'
            generic_risk['service'] = service_name
            generic_risk['port'] = port
            if version:
                generic_risk['version'] = version
            return generic_risk
        return None
    def downgrade_severity(self, severity: str) -> str:
        """Downgrade severity for infrastructure/devices"""
        severity_map = {
            'CRITICAL': 'HIGH',
            'HIGH': 'MEDIUM',
            'MEDIUM': 'LOW',
            'LOW': 'LOW'
        }
        return severity_map.get(severity.upper(), severity)
    def upgrade_severity(self, severity: str) -> str:
        """Upgrade severity for high-risk devices"""
        severity_map = {
            'LOW': 'MEDIUM',
            'MEDIUM': 'HIGH',
            'HIGH': 'CRITICAL',
            'CRITICAL': 'CRITICAL'
        }
        return severity_map.get(severity.upper(), severity)
    def check_port_based_risks(self, ports: List[Dict], is_infrastructure: bool, device_type: str) -> List[Dict]:
        """Check for risks based on open ports with AI context"""
        risks = []
        port_numbers = [p.get('port', 0) for p in ports]
        high_risk_ports = {
            23: {
                'service': 'Telnet',
                'severity': 'CRITICAL',
                'description': 'Credentials transmitted in plain text',
                'remediation': 'Replace with SSH',
                'ai_risk_score': 0.9
            },
            21: {
                'service': 'FTP',
                'severity': 'HIGH',
                'description': 'Often unencrypted, default credentials',
                'remediation': 'Use SFTP or FTPS',
                'ai_risk_score': 0.8
            },
            161: {
                'service': 'SNMP',
                'severity': 'HIGH',
                'description': 'Default community strings often used',
                'remediation': 'Use SNMPv3 with authentication',
                'ai_risk_score': 0.7
            },
            445: {
                'service': 'SMB',
                'severity': 'HIGH',
                'description': 'Target of EternalBlue and other exploits',
                'remediation': 'Disable SMBv1, use strong passwords',
                'ai_risk_score': 0.8
            },
            3389: {
                'service': 'RDP',
                'severity': 'HIGH',
                'description': 'Common target for brute force attacks',
                'remediation': 'Use Network Level Authentication',
                'ai_risk_score': 0.7
            },
            5900: {
                'service': 'VNC',
                'severity': 'HIGH',
                'description': 'Default passwords, often unencrypted',
                'remediation': 'Use SSH tunneling',
                'ai_risk_score': 0.8
            }
        }
        for port, risk_info in high_risk_ports.items():
            if port in port_numbers:
                severity = risk_info['severity']
                ai_risk_score = risk_info['ai_risk_score']
                if 'iot' in device_type or 'camera' in device_type:
                    ai_risk_score *= 1.3
                    severity = self.upgrade_severity(severity)
                if is_infrastructure:
                    severity = self.downgrade_severity(severity)
                    ai_risk_score *= 0.7
                risks.append({
                    'id': f'PORT-RISK-{port}',
                    'title': f'{risk_info["service"]} on port {port}',
                    'description': risk_info['description'],
                    'severity': severity,
                    'confidence': 'HIGH',
                    'type': 'port_risk',
                    'port': port,
                    'remediation': risk_info['remediation'],
                    'ai_risk_score': ai_risk_score,
                    'infrastructure_note': 'Infrastructure device' if is_infrastructure else None,
                    'device_type_note': device_type if device_type != 'unknown' else None
                })
        return risks
    def predict_iot_vulnerabilities(self, device_info: Dict, nmap_results: Dict) -> List[Dict]:
        """Predict common IoT vulnerabilities based on patterns"""
        vulnerabilities = []
        device_type = device_info.get('device_type', '').lower()
        vendor = device_info.get('vendor', '').lower()
        services = nmap_results.get('services', {})
        iot_patterns = [
            {
                'condition': lambda: 'http' in services and 'upnp' in services,
                'title': 'IoT Device with HTTP and UPnP',
                'description': 'Common IoT configuration with both web interface and UPnP enabled',
                'severity': 'HIGH',
                'ai_risk_score': 0.7,
                'remediation': 'Disable UPnP if not needed, secure web interface'
            },
            # Telnet check removed as it is already covered by check_port_based_risks (Port 23)
            {
                'condition': lambda: any('dahua' in vendor or 'hikvision' in vendor for s in services),
                'title': 'Security Camera with Default Credentials',
                'description': 'Known security camera brand often using default credentials',
                'severity': 'HIGH',
                'ai_risk_score': 0.8,
                'remediation': 'Change default admin password immediately'
            },
            {
                'condition': lambda: 'rtsp' in services and not any('http' in s for s in services),
                'title': 'RTSP Camera without Authentication',
                'description': 'Camera streaming RTSP without web interface or authentication',
                'severity': 'HIGH',
                'ai_risk_score': 0.7,
                'remediation': 'Enable authentication on RTSP stream'
            }
        ]
        for pattern in iot_patterns:
            try:
                if pattern['condition']():
                    vulnerabilities.append({
                        'id': f'IOT-PRED-{len(vulnerabilities)}',
                        'title': pattern['title'],
                        'description': pattern['description'],
                        'severity': pattern['severity'],
                        'confidence': 'MEDIUM',
                        'type': 'iot_pattern_prediction',
                        'ai_risk_score': pattern['ai_risk_score'],
                        'remediation': pattern['remediation'],
                        'prediction_basis': 'Common IoT vulnerability pattern'
                    })
            except:
                continue
        return vulnerabilities
    def deduplicate_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Remove duplicate vulnerabilities"""
        unique_vulns = []
        seen_ids = set()
        for vuln in vulnerabilities:
            vuln_id = vuln.get('id', '') or f"{vuln.get('type', '')}_{vuln.get('title', '')}"
            if vuln_id not in seen_ids:
                unique_vulns.append(vuln)
                seen_ids.add(vuln_id)
        return unique_vulns
    def sort_vulnerabilities_by_ai_risk(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Sort vulnerabilities by AI risk score and severity"""
        severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}
        def sort_key(vuln):
            severity = vuln.get('severity', 'MEDIUM').upper()
            ai_score = vuln.get('ai_risk_score', 0.0)
            return (severity_order.get(severity, 3), -ai_score)
        return sorted(vulnerabilities, key=sort_key)
